<!DOCTYPE html>
<html>
<style>
#container {
  width: 500px;
  height: 300px;
  position: relative;
  background: lightBlue;
  overflow: hidden;   /* clip anything outside the container */
}

#animate {
  width: 30px;
  height: 30px;
  position: absolute;
  bottom: 30px;
  left: 5px;
}
#floor1 {
    width: 45px;
    height: 30px;
    position: absolute;
    background: green;
    bottom: 0px;
    left: 0px;
}
#water1 {
    width: 110px;
    height: 10px;
    position: absolute;
    background: blue;
    bottom: 0px;
    left: 45px;
}
#floor2 {
    width: 40px;
    height: 30px;
    position: absolute;
    background: green;
    bottom: 0px;
    left: 155px;
}
#water2 {
    width: 110px;
    height: 10px;
    position: absolute;
    background: blue;
    bottom: 0px;
    left: 195px; 
}
#floor3 {
    width: 40px;
    height: 30px;
    position: absolute;
    background: green;
    bottom: 0px;
    left: 305px;
}
#water3 {
    width: 110px;
    height: 10px;
    position: absolute;
    background: blue;
    bottom: 0px;
    left: 345px; 
}
#floor4 {
    width: 45px;
    height: 30px;
    position: absolute;
    background: green;
    bottom: 0px;
    left: 455px; 
}
#statsDiv {
    position: absolute;
    top: 0px;
    right: 0px;
}
#floor1, #floor2, #floor3, #floor4 {
    z-index: 2;   /* floors above water but below wolf normally */
}
#water1, #water2, #water3 {
    z-index: 3;   /* water above floors */
}
#animate {
    z-index: 4;   /* wolf normally above everything */
}
</style>

<script src='../externalJS/gcf.js'></script>

<script>
// GLOBAL VARIABLES
var firstAttempt, reset=false, numCorrect=0, level=1;
var numberAttempted=0, numberCorrect=0, percentCorrect;
var jumpInProgress = false;
var a, h, k, b, c;
var result; // 'correct' or 'incorrect'

// celebration interval id (global so we can stop it)
var celebrateID = null;

// CONSTANTS
var START_LEFT = 3;
var START_BOTTOM = 30;

// RESET POSITION
function resetPosition() {
  var animate = document.getElementById("animate");
  animate.style.left = START_LEFT + "px";
  animate.style.bottom = START_BOTTOM + "px";
  animate.style.zIndex = 4;
} // end of resetPosition()

// LOAD PAGE
function loadPage() {
  document.getElementById('newButton').focus();
  document.getElementById('standardFormSpan').style.display='none';
  document.getElementById('checkButton').style.display='none';
  getStats();
  resetPosition();
} // end of loadPage()

// QUADRATIC BEZIER ARC
function getArcY(progress, startY, endY, peak) {
  var t = progress;
  var oneMinusT = 1 - t;
  return (oneMinusT*oneMinusT*startY) + (2*oneMinusT*t*peak) + (t*t*endY);
} // end of getArcY()

// GENERALIZED JUMP
function jump(distance, targetBottom, jumpHeight, fail) {
    if (jumpInProgress) return;
    // if a celebration bounce is running, stop it while jumping
    stopCelebrationBounce();

    jumpInProgress = true;

    var animate = document.getElementById("animate");
    var startLeft = parseFloat(animate.style.left) || START_LEFT;
    var startBottom = parseFloat(animate.style.bottom) || START_BOTTOM;

    // original pace: one pixel per interval
    var totalSteps = Math.max(1, Math.floor(Math.abs(distance))); // avoid 0
    var stepX = distance / totalSteps; // will be 1 if distance==totalSteps
    var peak = Math.max(startBottom, targetBottom) + jumpHeight;
    var counter = 0;

    // Hide new button while jumping
    document.getElementById('newButton').style.visibility = 'hidden';
    // Wolf z-index (falls behind water on fail if needed)
    animate.style.zIndex = fail ? 1 : 4;

    var id = setInterval(function() {
        counter++;
        var progress = counter / totalSteps;
        animate.style.left = (startLeft + stepX*counter) + "px";
        animate.style.bottom = getArcY(progress, startBottom, targetBottom, peak) + "px";

        if(counter >= totalSteps){
            clearInterval(id);
            // ensure final precise position
            animate.style.left = (startLeft + distance) + "px";
            animate.style.bottom = targetBottom + "px";
            jumpInProgress = false;

            // If this was a correct answer and it completed a 3-streak, level up now
            if(result === 'correct' && numCorrect === 3){
                // increment level and set reset flag so newProblem() will reset
                level++;
                numCorrect = 0;
                reset = true;

                document.getElementById('feedbackDiv').innerHTML = 
                    'Correct!  You have made it to Level ' + level + '!';
                document.getElementById('statsDiv').innerHTML = 'Level: ' + level;

                // Start continuous celebratory bounce (will not go below current bottom)
                startCelebrationBounce();

                // Show New Problem button
                document.getElementById('newButton').style.visibility='visible';
                document.getElementById('newButton').focus();
            } else {
                // normal feedback path (includes incorrect and correct-but-less-than-3 cases)
                giveFeedback();
            }
        }
    }, 5); // original animation speed (small = smooth)
} // end of jump()

// SAFE AND FAIL JUMPS
function jumpSafe() { jump(150, 30, 40, false); } // end of jumpSafe()
function jumpFail() { jump(110, 5, 30, true); } // end of jumpFail()

// NEW PROBLEM (user clicks)
function newProblem() {
    if(jumpInProgress) return; // do not interrupt animation

    // stop celebration if running (and restore bottom to stable base)
    stopCelebrationBounce();

    // Only reset the wolf when allowed (after a wrong answer or after level-up)
    if (reset) {
      resetPosition();
      reset = false;
    }

    getNewProblemDisplay();
    firstAttempt = true;

    document.getElementById('statsDiv').innerHTML = 'Level: ' + level;
    getVertexForm();
    displayProblem();
    document.getElementById('answerInput1').focus();
} // end of newProblem()

function getVertexForm() {
    a = getRandom(-10, 9); if (a===0) {a=10;}
    h = getRandom(-20, 20);
    k = getRandom(-20, 20);
    
    b = -2*a*h;
    c = a*h*h + k;
    
    correctAnswer1 = a;
    correctAnswer2 = b;
    correctAnswer3 = c;
} // end of getVertexForm()

// DISPLAY
function displayProblem() {
    var problem = 'Convert the vertex form equation into standard form.<br /><br />';
    problem += 'y = ';
    // correct display a
    if (a===1) {problem += '';}
    else if (a===-1) {problem += '&ndash;';}
    else if (a < 0) {problem += '&ndash;' + Math.abs(a);}
    else {problem += a;}
    problem += '(x ';
    // correctly display x - h
    if (h<0) {problem += '+ ' + Math.abs(h)}
    else {problem += '&ndash; ' + h;}
    problem += ')<sup>2</sup> ';
    // correct display k
    if (k<0) {problem += '&ndash; ' + Math.abs(k);}
    else if (k>0) {problem += '+ ' + k;}
    else {problem += '';} // k is zero... nothing to display
    document.getElementById('problemDiv').innerHTML = problem;
} // end of displayProblem()

function getNewProblemDisplay() {
    document.getElementById('newButton').style.visibility='hidden';
    document.getElementById('answerInput1').value='';
    document.getElementById('answerInput2').value='';
    document.getElementById('answerInput3').value='';
    document.getElementById('feedbackDiv').innerHTML='&nbsp;';
    document.getElementById('checkButton').style.display='inline';
    document.getElementById('standardFormSpan').style.display='inline';
    document.getElementById('errorDiv').style.visibility='hidden';
} // end of getNewProblemDisplay()

// RANDOM NUMBER
function getRandom(min,max){return Math.floor(Math.random()*(max-min+1))+min;} // end of getRandom()

// CHECK ANSWER
function checkAnswer(){
    if(document.getElementById('answerInput1').value!=='' &&
       document.getElementById('answerInput2').value!=='' &&
       document.getElementById('answerInput3').value!==''){
       
        document.getElementById('errorDiv').style.visibility='hidden';
        document.getElementById('checkButton').style.display='none';

        if(firstAttempt){
            var userAnswer1=document.getElementById('answerInput1').value;
            var userAnswer2=document.getElementById('answerInput2').value;
            var userAnswer3=document.getElementById('answerInput3').value;

            if(userAnswer1==correctAnswer1 && userAnswer2==correctAnswer2 && userAnswer3==correctAnswer3){
                result='correct';
                numCorrect++; // consecutive correct count
                // do NOT set reset here â€” reset is set only after level-up (in jump) or on wrong answer below
                jumpSafe();
            } else {
                result='incorrect';
                // mark for reset when newProblem is clicked
                reset=true;
                jumpFail();
                numCorrect=0;
            }
        }

        firstAttempt=false;
    } else {
        document.getElementById('errorDiv').style.visibility='visible';
        document.getElementById('answerInput1').focus();
    }
} // end of checkAnswer()

// FEEDBACK (runs after non-level-up jumps)
function giveFeedback(){
    if(result==='correct') {
        document.getElementById('feedbackDiv').innerHTML='<br />Correct!';
    }
    else if(result==='incorrect') {
        document.getElementById('feedbackDiv').innerHTML='<br />Correct answer: ';
        document.getElementById('feedbackDiv').innerHTML += 'y = ' + a + 'x<sup>2</sup> + ' + b + 'x + ' + c + '<br />Try again!';
    }

    // Show New Problem button so user can proceed when ready
    document.getElementById('newButton').style.visibility='visible';
    document.getElementById('newButton').focus();
} // end of giveFeedback()

// START CELEBRATORY BOUNCE (repeating until stopped)
function startCelebrationBounce() {
    // If already running, do nothing
    if (celebrateID) return;

    var animate = document.getElementById("animate");
    // baseBottom is the vertical position the wolf landed at; bounce from here upward only
    var baseBottom = parseFloat(animate.style.bottom) || START_BOTTOM;
    var bounceHeight = 18; // px above landing position
    var frames = 24;       // frames per half-bounce (controls smoothness)
    var frameTime = 18;    // ms per frame (~55fps)
    var t = 0;
    var direction = 1; // 1 = up phase, -1 = down phase

    // Use a smooth ease function for each half-cycle (quadratic ease-out/in)
    celebrateID = setInterval(function() {
        // progress in current half-cycle (0..1)
        var p = t / frames;
        // ease: easeOutQuad then easeInQuad across the half-cycle pair
        // for a single half cycle use eased = 1 - (1-p)^2 (easeOutQuad)
        var eased = 1 - Math.pow(1 - p, 2);

        // compute current bottom depending on phase
        if (direction === 1) {
            // moving up from baseBottom to baseBottom + bounceHeight
            animate.style.bottom = (baseBottom + eased * bounceHeight) + "px";
        } else {
            // moving down from baseBottom + bounceHeight back to baseBottom
            animate.style.bottom = (baseBottom + (1 - eased) * bounceHeight) + "px";
        }

        t++;
        if (t > frames) {
            t = 0;
            direction = -direction; // switch direction (up -> down or down -> up)
        }
    }, frameTime);
} // end of startCelebrationBounce()

// STOP CELEBRATORY BOUNCE
function stopCelebrationBounce() {
    if (celebrateID) {
        clearInterval(celebrateID);
        celebrateID = null;
        // restore to exact base bottom (in case interval left it mid-value)
        var animate = document.getElementById("animate");
        var base = parseFloat(animate.style.bottom) || START_BOTTOM;
        animate.style.bottom = base + "px";
    }
} // end of stopCelebrationBounce()

// STATS
function getStats(){
    if(numberAttempted===0) percentCorrect='';
    else percentCorrect = roundDecimalNumber(100*numberCorrect/numberAttempted,1);
    document.getElementById('statsDiv').innerHTML='Level: '+level;
} // end of getStats()

// ROUND DECIMAL
function roundDecimalNumber(number,places){
    number = number*Math.pow(10,places);
    number = number.toFixed(0);
    number = number/Math.pow(10,places);
    return number;
} // end of roundDecimalNumber()
</script>



<body onload="loadPage()">
  <h3>Convert Vertex Form to Standard Form</h3>
  <div id="container">
    <button id="newButton" onclick="newProblem()">New problem</button>
    <br /><br />
    <span id="problemDiv">Click the button above to get a new problem</span>
    <br /><br />
    <span id='standardFormSpan'>
      y = 
      <input type="text" id="answerInput1" style="width:50px;" />
      x<sup>2</sup> +
      <input type="text" id="answerInput2" style="width:50px;" />
      x + 
      <input type='text' id='answerInput3' style='width:50px' />
    </span>
    <button id="checkButton" onclick="checkAnswer();">Check answer</button>
    <div id="errorDiv" style="color:red; visibility:hidden;">Type an answer in all boxes above</div>
    <span id="statsDiv">Stats</span>
    <span id="feedbackDiv">&nbsp;</span>
    <span id="floor1"></span>
    <span id="water1"></span>
    <span id="floor2"></span>
    <span id="water2"></span>
    <span id="floor3"></span>
    <span id="water3"></span>
    <span id="floor4"></span>
    <span id="animate"><img src="../images/wolf transparent.png" style="width:150%; height:150%"></span>
  </div>
</body>
</html>
